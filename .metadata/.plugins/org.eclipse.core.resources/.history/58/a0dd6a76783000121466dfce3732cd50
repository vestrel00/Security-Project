package com.vestrel00.ssc.server;

import java.io.IOException;
import java.security.SecureRandom;

import com.vestrel00.ssc.server.datatypes.SSCPendingClient;
import com.vestrel00.ssc.server.datatypes.SSCServerClient;
import com.vestrel00.ssc.server.interf.SSCCrypto;
import com.vestrel00.ssc.server.interf.SSCServer;
import com.vestrel00.ssc.server.interf.SSCServerService;
import com.vestrel00.ssc.server.protocols.SSCServerMessageReceiver;
import com.vestrel00.ssc.server.protocols.SSCServerMessageSender;
import com.vestrel00.ssc.server.shared.SSCCryptoAES;
import com.vestrel00.ssc.server.shared.SSCSettings;
import com.vestrel00.ssc.server.shared.SSCStreamManager;

/**
 * An implementation of the SSCServerService that uses RSA to secure initial
 * client-server connection.
 * 
 * @author Estrellado, Vandolf
 * @see SSCServerService
 * 
 */
public class SSCSServiceStandard implements SSCServerService {

	private SSCServerMessageSender sender;
	private SSCServerMessageReceiver receiver;
	private SSCCrypto crypt;
	private SSCServer serverClass;
	private SSCServerService clientPartnerService;
	private boolean inService, isInChat;
	private SecureRandom rand;
	private SSCServerClient client;

	/**
	 * Need the following to be field members so other service objects have
	 * access to them.
	 */
	private byte[] secretKey, confirmCode;

	/**
	 * Create the service.
	 * 
	 * @param serverClass
	 *            The server which launched this service.
	 * @param client
	 *            The client that will be serviced.
	 */
	public SSCSServiceStandard(SSCServer serverClass, SSCServerClient client) {
		this.serverClass = serverClass;
		this.client = client;
		inService = true;
		rand = new SecureRandom();
	}

	/**
	 * Uses RSA to secure login or creation of new account. Will end the service
	 * if password does not match with username three times.
	 * <ol>
	 * <li>Send public key</li>
	 * <li>TODO</li>
	 * </ol>
	 * 
	 * @throws IOException
	 */
	// TODO replace with actual implementation!
	public boolean login() throws IOException {
		int attempts = 0;
		SSCStreamManager.sendBytes(client.getOutputStream(),
				"Login or Create new account? (login | create)".getBytes());
		String choice = new String(SSCStreamManager.readBytes(client
				.getInputStream()));
		if (choice.contentEquals("login")) {
			while (attempts < 3) {
				SSCStreamManager.sendBytes(client.getOutputStream(),
						"Enter username".getBytes());
				String uname = new String(SSCStreamManager.readBytes(client
						.getInputStream()));
				SSCStreamManager.sendBytes(client.getOutputStream(),
						"Enter password".getBytes());
				String pass = new String(SSCStreamManager.readBytes(client
						.getInputStream()));
				if (true) {// if(database.authenticate(uname, pass))
					if (serverClass.clientIsOnline(uname)) {
						attempts++;
						SSCStreamManager.sendBytes(client.getOutputStream(),
								"bad".getBytes());
					} else {
						client.setName(uname);
						SSCStreamManager.sendBytes(client.getOutputStream(),
								"good".getBytes());
						return true;
					}
				} else {
					SSCStreamManager.sendBytes(client.getOutputStream(),
							"bad".getBytes());
					attempts++;
				}
			}
			return false;
		} else if (choice.contentEquals("create"))
			return createAccount();
		else
			return false;

	}

	private boolean createAccount() {
		// TODO store in database H(m) and the salt
		return true;
	}

	@Override
	public void stopService() {
		if (inService) {
			inService = false;
			client.closeIO();
			serverClass.removeService(client.getName(), client.getBuffer()
					.getBufferId());
			try {
				if (client != null)
					client.getSocket().close();
				client = null;
			} catch (IOException e) {
				e.printStackTrace();
			}
		}
	}

	@Override
	public void run() {
		try {
			login();
			option();;
		} catch (IOException e) {
			stopService();
		}

		// isOutputShutdown checks if client is still able to write to us
		while (inService && !client.getSocket().isOutputShutdown()) {
			if (sender != null && !sender.work())
				stopService();
		}
	}

	/**
	 * <p>
	 * Launch the receiver thread that will listen for incoming client messages.
	 * We then wait for the client to create another socket to get a new pair of
	 * in/out streams. Proceed when the pending client is in the server pending
	 * list.
	 * </p>
	 * 
	 * @throws IOException
	 * 
	 */
	// TODO wrap with RSA
	private void initReceiver() throws IOException {
		// retrieve the client from the pending list
		// blocks until client is in pending list
		SSCPendingClient pc = serverClass.retrievePendingClient(client
				.getName());
		// client and server now has new socket pairs to use! send OK.
		SSCStreamManager.sendBytes(pc.getOutputStream(), "OK".getBytes());

		// finally init and launch the receiver
		receiver = new SSCServerMessageReceiver(this, pc.getSocket(), crypt);
		new Thread(receiver).start();
	}

	/**
	 * login succeeded now connect to another client that is also logged in the
	 * server. Perform the client-client connection protocol with the server
	 * service. <b>Server computes both the private key and confirm code</b>
	 * 
	 * @throws IOException
	 */
	// TODO wrap with RSA
	private void connect() throws IOException {
		boolean retry = true;
		while (retry) {
			// wait for requested client's username
			client.setPartnerName(new String(SSCStreamManager.readBytes(client
					.getInputStream())));
			if (client.getPartnerName().contentEquals(client.getName()))
				SSCStreamManager.sendBytes(client.getOutputStream(),
						"nonsense".getBytes());
			else if (serverClass.clientIsOnline(client.getPartnerName())) {
				clientPartnerService = serverClass.getServiceByName(client
						.getPartnerName());
				SSCStreamManager.sendBytes(client.getOutputStream(),
						"online".getBytes());
				retry = false;
			} else
				SSCStreamManager.sendBytes(client.getOutputStream(),
						"unavailable".getBytes());
		}
		initSender();
		initReceiver();
	}

	/**
	 * <p>
	 * Need to decide which service will compute the session keys. So whoever
	 * gets here first is the one!
	 * </p>
	 * The service that gets here first compute the secret key and confirm code
	 * that is passed onto the protocol which passes onto the crypto.
	 * 
	 * @throws IOException
	 */
	// TODO wrap with RSA
	private void initSender() throws IOException {
		isInChat = true;
		if (!clientPartnerService.isInChat()) {
			// this service got here first - compute keys!
			// generate secretKey
			secretKey = new byte[16];
			rand.nextBytes(secretKey);
			// generate the confirmCode
			confirmCode = new byte[4];
			rand.nextBytes(confirmCode);
			// set the keys for the other service in wait
			clientPartnerService.setSecretKey(secretKey);
			clientPartnerService.setConfirmCode(confirmCode);
		} else { // this got here after the other service already computed keys
			// wait for the other service to send over secret key
			while (secretKey == null && confirmCode == null)
				continue;
		}
		// both services have the keys ready to send to their clients
		SSCStreamManager.sendBytes(client.getOutputStream(), secretKey);
		SSCStreamManager.readBytes(client.getInputStream()); // wait for client
																// ok
		SSCStreamManager.sendBytes(client.getOutputStream(), confirmCode);
		crypt = new SSCCryptoAES(secretKey, confirmCode);
		sender = new SSCServerMessageSender(this, crypt);
	}

	public SSCServer getServerClass() {
		return serverClass;
	}

	@Override
	public SSCServerClient getClient() {
		return client;
	}

	@Override
	public SSCServerService getClientPartnerService() {
		return clientPartnerService;
	}

	@Override
	public boolean isInChat() {
		return isInChat;
	}

	@Override
	public void setSecretKey(byte[] secretKey) {
		this.secretKey = secretKey;
	}

	@Override
	public void setConfirmCode(byte[] confirmCode) {
		this.confirmCode = confirmCode;
	}

	@Override
	public SSCServerMessageReceiver getReceiver() {
		return receiver;
	}

	@Override
	public SSCServerMessageSender getSender() {
		return sender;
	}

}
